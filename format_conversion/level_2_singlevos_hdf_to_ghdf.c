/***************************************************************************** 
 * level_2_singlevos_hdf_to_ghdf.c -- 
 *    Combine one or more single VOS hdf file(s) to one granuled HDF file
 *    for either 2A-53, 2A-54, 2A-55.
 *
 *    This program places all single VOS hdf file(s) listed on the 
 *    command line to one granuled HDF file without checking
 *    whether they belong to the same granule.  A granule is defined
 *    a collection of data spanning one hour.
 *
 *    In order to create the granule HDF file, metadata from the level 1C
 *    granule is needed.
 *
 *
 * By:    Thuy Nguyen
 *        NASA/TRMM Office
 *        Thuy.Nguyen@gsfc.nasa.gov
 *        June 13, 1996
 *
 * Mods:  John Merritt
 *        SM&A
 *        February 11, 2000
 *
 ****************************************************************************/
/*
 * Note:
 *
 * This routine will copy the generic metadata fields from
 * the qc hdf file which corresponds to the output file and the product 
 * specific metadata fields from the first single vos hdf file to
 * the output file.
 */

#include <signal.h>
#include <stdio.h>
#include <string.h>
#include <sys/stat.h>
#include <unistd.h>
#include <ctype.h>
#include <sys/types.h>
#include <dirent.h>
#include <stdlib.h>

/* TSDIS toolkit include files*/
#include <IO.h>
#include <IO_GV.h>
#include <TKerrHandle.h>
#include <TS_GVFC_61.h>
#include <gv_utils.h>
#include "gvs_metadata.h"

                   

#define MAX_STR_LEN 300

#define MAX_VOS_NUM  MAX_VOS   /* max. num. of vos per granule */

union _grid{
	L2A_53_SINGLE_RADARGRID g2A53;
	L2A_54_SINGLE_RADARGRID g2A54;
	L2A_55_SINGLE_RADARGRID g2A55;
  };

int verbose;
int remove_shdf_files;             
int compress_ghdf_file;             

int write_metadata (char *qc_filename, char *first_infile, 
					char *metadata_file, char *param_file,
					DATE_STR *begin_date, 
					DATE_STR *end_date, TIME_STR *begin_time,
					TIME_STR *end_time, int nvos, 
					char pcode, char *outfile,
					IO_HANDLE *ghdf_fd);
int read_prod_specific_metadata_from_voshdf(char *vosfile,
											char pcode,
											gv_metadata_t *metadata);
int open_hdf_file(char *hdf_fname, char mode, char pcode, IO_HANDLE *hdf_fd);
int read_grid_from_shdf_file(char pcode, char *hdffile, void *grid,
  DATE_STR *vos_date, TIME_STR *vos_time);
void process_argv(int argc, char **argv, char *product_code, 
				  char *infile[MAX_VOS_NUM], char *outfile, int *verbose,
				  char **input_dir, char **output_dir, int *read_from_dir,
				  char **qc_dirs_list, char **metadata_file, char **param_file,
				  int *prod_ver_1c51)
{
  extern int optind;
  extern char *optarg;
  extern int optopt;
  
  int c, i;

  if (product_code == NULL || outfile == NULL || verbose == NULL) {
	TKreportWarning(W_GVFC_S2G_BAD_PARAMS);
	exit(-1);
  }
  if (argc  < 2) {
 USAGE:
	fprintf(stderr,
"Usage (%s): %s [-v] [-c] [-r] [-P ver#] [-i input_dir] [-o output_dir] \n"
"\t[-q qc_dirs_list] [-m metadata_file] [-p param_file] {3 | 4 | 5} \n"
"\t{ READ_FROM_DIR | \n"
"\t  {shdf_file1 [shdf_file2 ... shdf_fileN] ghdf_file}\n"
"\t}\n"
" where:\n"
"\t3 = 2A-53; 4 = 2A-54; 5 = 2A-55\n"
"\t-r:   Will remove the single VOS hdf files as it's done.\n"
"\t-c:   Will compress the granulized hdf file(s) as they are produced.\n"
"\t-i:   Specify dir. that contains single VOS HDF files. Default: './'.\n"
"\t-o:   Specify dir. to store the output files. This dir will not \n"
"\t      be used if ghdf_file contains pathname. Default: './'.\n"
"\t-q:   Specify dir(s) that contain granuled QC HDF files. \n"
"\t      Directories are separated by ':'.  \n"
"\t      This program will copy the generic metadata fields from \n"
"\t      a QC file to the granuled HDF file. Default: './'.\n"
"\t-m:   Specify metadata.txt filename.  This file contains metadata\n"
"\t      options, including the product version number.\n"
"\t      Default: $GVS_DATA_DIR/2A53_metadata.txt\n"
"\t-p:   Other runtime parameters.  Usually this is a list of input files and"
"\t      is generated by the program 2A-53or2A-55.  Default: NONE.\n"
"\t-P n: Specify the product version number of 1C-51 files.  Default: Use\n"
"\t      the same product version number as input shdf files.\n"
"\t      For example, when using product version 2 of 1C-51, but the product\n"
"\t      version for 2A-54 is 3."
"NOTE:\n"
"\tIf READ_FROM_DIR is specified, this program will determine which\n\tfile(s)"
"\tbelong to which granule and construct granuled file(s) appropriately;\n"
"\totherwise, it expects shdf_file<i> to be listed in the sequential order \n"
"\tand belong to the same hour-granule.\n"
"\n"
"\tAlso, 1C filenames are constructed from the shdf_file# filenames.\n"
"\tFor example, 2A54.960726.24.KWAJ.3.2305.hdf will try to find 1C51.960726.24.KWAJ.3.HDF\n"
"\n", PROG_VERSION, argv[0]);
	TKreportWarning(W_GVFC_S2G_BAD_USAGE);
	exit(-1);
  }

  while ((c = getopt(argc, argv, "i:o:q:m:p:P:vrc")) != -1) {
	switch(c) {
	case 'c': compress_ghdf_file = 1; break;
	case 'r': remove_shdf_files  = 1; break;
	case 'v': *verbose           = 1;  break;
	case 'i': *input_dir         = strdup(optarg); break;
	case 'q': *qc_dirs_list      = strdup(optarg);  break;
	case 'm': *metadata_file     = strdup(optarg);  break;
	case 'p': *param_file        = strdup(optarg);  break;
	case 'P': *prod_ver_1c51     = atoi(optarg);  break;
	case 'o': *output_dir        = strdup(optarg);  break;
	case '?': 
	  fprintf(stderr, "option -%c is undefined\n", optopt);
	  goto USAGE;
    case ':':
	  fprintf(stderr, "option -%c requires an argument\n",optopt);
	  goto USAGE;
    default: break;
    }
  }
  /* must have at least 3 items listed */
  if (argc - optind < 2) goto USAGE;
  *product_code =  argv[optind++][0];
  switch(*product_code) {
  case '3':
  case '4':
  case '5':
	break;
  default:
	goto USAGE;
  }
  if (strcmp(argv[optind], "READ_FROM_DIR") == 0) {
	*read_from_dir = 1;
	return;
  }

  if (argc - optind < 2) goto USAGE;


  /* get input file(s) */
  i = 0;
  while (optind > 0 && optind < (argc - 1)) {
	infile[i++] = argv[optind++];
  }
  /*  get output file */
  strcpy(outfile, argv[optind]);

}

void find_file_from_dirs(
						char *qc_filename, 
						char *qc_dirs_list, 
						char *full_qc_filename)
{
  /* Find the qc_filename from the list qc_dirs_list.  That file might 
   * be compressed.
   * qc_dirs_list is a list of directories separated by ':'.
   * Return full_qc_filename = dir/qc_filename[.gz|.Z], where dir is 
   * in the dir list.
   */
  char *tmp_str, *tmp_str1 = NULL, *dir = NULL;
  char fname[MAX_FILENAME_LEN];
  struct stat status;
  
  if (full_qc_filename == NULL) return;
  if (qc_dirs_list == NULL || qc_filename == NULL) {
	strcpy(full_qc_filename, "");
	return;
  }
  strcpy(full_qc_filename, "");
  tmp_str = qc_dirs_list;
  while (tmp_str) {
	tmp_str1 = strchr(tmp_str, ':');
	if (tmp_str1 != NULL) {
	  /* Extract a top dir and forward tmp_str1 1 char.*/
	  tmp_str1++;                /* Skip ':' */
	  *(tmp_str1-1) = '\0';      /* Makes tmp_str a dir name */
	}
	dir = tmp_str;
	memset(fname, '\0', MAX_FILENAME_LEN);
	sprintf(fname, "%s/%s", dir, qc_filename);
	strcpy(full_qc_filename, fname);

	/* Check if it exists as non compress or compressed and change the filename
	 * appropriately.
	 */
	if (stat(full_qc_filename, &status) < 0) {
	/* File does not exist check for compressed file  ends with .gz */
	  strcat(full_qc_filename, ".gz");
	  if (stat(full_qc_filename, &status) < 0) {
		/* File does not exist check for compressed file  ends with .Z */
		strcpy(full_qc_filename, fname);
		strcat(full_qc_filename, ".Z");
		if (stat(full_qc_filename, &status) < 0) {
		/* File does not exist, clear fname */
		  strcpy(full_qc_filename, "");
		}
	  }
	}
	if (strlen(full_qc_filename) > 0) break;
	tmp_str = tmp_str1; 
  }

} /* find_file_from_dirs */

char *find_file(char *pattern)
{
  /* Look in current directory for file having 'pattern'. */
  /* Uses 'ls' and shell wildcard expansion. */
  char cmd[1000];
  char line[1000];
  FILE *fp;
  char *result = NULL;

  sprintf(cmd,"ls -1r %s 2>/dev/null", pattern);
  fp = popen(cmd, "r");
  if (fscanf(fp, "%s", line) > 0) {
	result = strdup(line);
  } else {
	result = NULL;
  }
  pclose(fp);
  return result;
}

char *find_file_in_dirlist(char *filename, char *dir_list)
{
  char *tmp_str, *tmp_str1 = NULL, *dir = NULL;
  char fname[MAX_FILENAME_LEN];
  char *full_filename; /* Final result, dynamically allocated and returned. */
  
  if (dir_list == NULL || filename == NULL) return NULL;

  tmp_str = strdup(dir_list);

  while (tmp_str) {
	tmp_str1 = strchr(tmp_str, ':');
	if (tmp_str1 != NULL) {
	  /* Extract a top dir and forward tmp_str1 1 char.*/
	  tmp_str1++;                /* Skip ':' */
	  *(tmp_str1-1) = '\0';      /* Makes tmp_str a dir name */
	}
	dir = tmp_str;
	memset(fname, '\0', MAX_FILENAME_LEN);
	sprintf(fname, "%s/%s", dir, filename);

	/* Check if it exists as non compress or compressed and change the filename
	 * appropriately.
	 */
	full_filename = find_file(fname);
	if (full_filename == NULL) { /* Check .gz */
	  sprintf(fname, "%s/%s.gz", dir, filename);
	  full_filename = find_file(fname);
	}
	if (full_filename == NULL) { /* Check .Z */
	  sprintf(fname, "%s/%s.Z", dir, filename);
	  full_filename = find_file(fname);
	}
	if (full_filename) break;
	tmp_str = tmp_str1;
  }

  return full_filename;

} /* find_file_from_dirs */

void get_qc_hdf_fname(char *l2vos_hdf_fname, char *qc_dirs_list,
					  int prod_ver_qc_opt, char *qc_filename)
{
  /* Get qc hdf filename associated with l2vos_hdf_fname if it exists
   * in any of the dir from qc_dirs_list.
   */
  char tmp_fname[MAX_FILENAME_LEN], base_fname[MAX_FILENAME_LEN],
	full_qc_filename[MAX_FILENAME_LEN];
  char *tmp_ptr;
  char qc_file[MAX_FILENAME_LEN];
  char qc_file_save[MAX_FILENAME_LEN];
  int prod_ver_qc;

  if (l2vos_hdf_fname == NULL || qc_filename == NULL) return;

  prod_ver_qc = prod_ver_qc_opt;
  memset(base_fname, '\0', MAX_FILENAME_LEN);
  memset(tmp_fname, '\0', MAX_FILENAME_LEN);
  /* Construct base file name with no pathname*/
  if (construct_ghdf_filename(l2vos_hdf_fname, "1C51", "", tmp_fname) < 0) {
	if (verbose)
	  fprintf(stderr, "Unable to construct granule hdf filename base on %s\n",l2vos_hdf_fname); 
	memset(full_qc_filename, '\0', MAX_FILENAME_LEN);
	strcpy(qc_filename, full_qc_filename);
	return;
  }

  /* tmp_fname, i.e.:  2A54.921002.12.MELB.1.HDF
   * want qc_file: 1C51.921002.12.MELB.1.HDF
   */  
  tmp_ptr = strrchr(tmp_fname, '/');
  if (tmp_ptr == NULL) tmp_ptr = tmp_fname;
  else tmp_ptr++;   /* Forward '/' */
 
  strcpy(qc_file, "1C51");
  strcat(qc_file, tmp_ptr+4);
  tmp_ptr = strrchr(qc_file, '.');  /* Positioned at the '.' in '*.HDF' */
  /* Now truncate at 2-nd '.' from right. We will truncate at each '.', one at a time,
   * until we have done it twice. */
  if (tmp_ptr) *tmp_ptr = '\0'; /* First one; we've seen the first period from the right. */

  tmp_ptr = strrchr(qc_file, '.'); /* Now, we see the second from the right. */
  if (tmp_ptr) {
	/* Record the product version number.  This will be
	 * used later, to find matching
	 * 1C files with the same product number.
	 */
	if (prod_ver_qc == 0) prod_ver_qc = atoi(tmp_ptr+1); /* Else -P overrides. */
	*tmp_ptr = '\0'; /* Second one; now we're ready for the new product #. */
	
  }
  strcpy(qc_file_save, qc_file);
  sprintf(qc_file,"%s.%d.HDF", qc_file, prod_ver_qc);

  memset(full_qc_filename, '\0', MAX_FILENAME_LEN);
  find_file_from_dirs(qc_file, qc_dirs_list, full_qc_filename);

  if (full_qc_filename[0] == '\0') { /* Perform a pattern match on the product version number
										and return the file that has the highest product version
										number.
									 */
	char *alt_file = NULL;
	fprintf(stderr, "Warning: Unable to find <%s> in directory list <%s>\n",
			qc_file, qc_dirs_list);
	if (prod_ver_qc_opt == 0) {
	  fprintf(stderr, "         Looking for highest product version number...\n");
	  sprintf(qc_file,"%s.*.HDF", qc_file_save);
	  alt_file = find_file_in_dirlist(qc_file, qc_dirs_list);
	  fprintf(stderr, "         Alternate file <%s>\n", alt_file);
	  
	  if (alt_file == NULL) {
		fprintf(stderr, "Warning: Still unable to find <%s> (including .gz or .Z) in directory list <%s>\n",
				qc_file, qc_dirs_list);
	  } else {
		strcpy(full_qc_filename, alt_file);
	  }
	}
  }
  /* full_qc_filename: [pathname]1C51.921002.11.MELB.1.HDF
   */  
  strcpy(qc_filename, full_qc_filename);

}




int granulize_hdf(char pcode, char *input_dir,
				  char *infile_list[MAX_VOS_NUM], char *qc_dirs_list, int prod_ver_qc,
				  char *metadata_file, char *param_file, char *outfile)
{
  /* Implode single VOS hdf file to granuled HDF file for product 
   * specified by pcode, assuming infile_list is in the right order and its 
   * file(s) belong to the same hourly granule.  
   *
   * This routine will copy the generic metadata fields from
   * the qc hdf file which corresponds to the output file and the product 
   * specific metadata fields from the first infile from infile_list to
   * the output file.
   *
   * This routine assumes qc hdf file and infiles have this naming convention: 
   *   qc:      1C51.yymmdd.granule#.site.ver#.HDF[.gz|.Z]   
   *   infile:  <prod>.yymmdd.granule#.site.ver#.hhmm.hdf[.gz|.Z]
   */
  int i;
  int nvos;
  IO_HANDLE ghdf_fd;
  void *pgrid;
  union _grid grid;
  char infile[MAX_FILENAME_LEN], ss_infile[MAX_FILENAME_LEN], 
	*dir, *infile_ptr=NULL;
  int  len;
  char qc_filename[MAX_FILENAME_LEN], tmp_fname[MAX_FILENAME_LEN];
  char first_infile[MAX_FILENAME_LEN], ss_first_infile[MAX_FILENAME_LEN],
	*tmp_ptr;
  DATE_STR begin_date, end_date;
  TIME_STR begin_time, end_time;
  int remove_first_file = 0, remove_tmp_file = 0;;
  
  if (outfile == NULL) return -1;
  /* open HDF file */
  if (open_hdf_file(outfile, TK_NEW_FILE, pcode, &ghdf_fd) < 0) {
	fprintf(stderr, "TKopen failed for file <%s>\n", outfile);
	TKreportWarning(W_GVFC_S2G_OPEN_OUTFILE_FAILED);
	return (-1);
  }

  switch (pcode) {
  case '3':  /* 2A-53 */
	pgrid = (void *) &grid.g2A53;
	memset(pgrid, '\0', sizeof(L2A_53_SINGLE_RADARGRID));
	break;

  case '4':  /* 2A-54 */
	pgrid = (void *) &grid.g2A54;
	memset(pgrid, '\0', sizeof(L2A_54_SINGLE_RADARGRID));
	break;
  case '5':  /* 2A-55 */
	pgrid = (void *) &grid.g2A55;
	memset(pgrid, '\0', sizeof(L2A_55_SINGLE_RADARGRID));
	break;

  default:
	fprintf(stderr, "product code <%c> is unknown\n", pcode);
	return -1;
  }


  if (input_dir) dir = input_dir;
  else dir = ".";
  /* For each input file, uncompress it if it is compressed, read it, 
   * append to the opened ghdf_file.
   */
  memset(first_infile, '\0', MAX_FILENAME_LEN);
  memset(ss_first_infile, '\0', MAX_FILENAME_LEN);
  remove_first_file = 0;
  for (i = 0; i < MAX_VOS_NUM && infile_list[i]; i++) {
	memset(infile, '\0', MAX_FILENAME_LEN);

	if (!(infile_list[i][0] == '/' || 
		(infile_list[i][0] == '.' && (infile_list[i][1] == '.' ||
									  infile_list[i][1] == '/' ))))
		/* Add dir to filename if it doesnot start with '/', './', '../' */
	  sprintf(infile, "%s/%s", dir, infile_list[i]);
	else 
	  strcpy(infile, infile_list[i]);

	/* Uncompress infile if it is compressed to a tmp file -- leave infile
	 * unmodified.
	 */
	remove_tmp_file = 0;
	strcpy(ss_infile, infile);
	if ((tmp_ptr = strstr(infile, ".gz")) || (tmp_ptr = strstr(infile, ".Z"))) {
	  if (strrchr(infile, '/') != (char *) NULL) 
		infile_ptr = strrchr(infile, '/') + 1;
	  else
		infile_ptr = infile;
	  len = strlen(infile_ptr) - strlen(tmp_ptr);
	  memset(tmp_fname, '\0', MAX_FILENAME_LEN);
	  strncpy(tmp_fname, infile_ptr, len);
	  uncompress_file(infile, tmp_fname);
	  strcpy(ss_infile, infile);
	  strcpy(infile, tmp_fname);
	  remove_tmp_file = 1;
	}


	if (verbose) 
	  fprintf(stderr, "reading grid from <%s>\n", infile);

	if (read_grid_from_shdf_file(pcode, infile, pgrid, &end_date, &end_time) < 0) {
	  fprintf(stderr, "Failed reading grid from shdf file <%s>\n",  infile);
	  TKreportWarning(W_GVFC_S2G_READ_INFILE_FAILED);
	  TKclose(&ghdf_fd);
	  return -1;
	}
	if (i == 0) {
	  strcpy(first_infile, infile);
	  strcpy(ss_first_infile, ss_infile);
	  remove_first_file = remove_tmp_file;
	  memcpy(&begin_date, &end_date, sizeof(DATE_STR));
	  memcpy(&begin_time, &end_time, sizeof(TIME_STR));
	}

	/*
	if (verbose) {
	  fprintf(stderr,"begin_date=<%2.2d/%2.2d/%4.4d>  begin_time=<%2.2d:%2.2d:%2.2d>\n",
			  (int)begin_date->tkmonth, (int)begin_date->tkday, (int)begin_date->tkyear,
			  (int)begin_time->tkhour, (int)begin_time->tkminute, (int)begin_time->tksecond);
	  fprintf(stderr,"  end_date=<%2.2d/%2.2d/%4.4d>    end_time=<%2.2d:%2.2d:%2.2d>\n",
			  (int)end_date->tkmonth, (int)end_date->tkday, (int)end_date->tkyear,
			  (int)end_time->tkhour, (int)end_time->tkminute, (int)end_time->tksecond);
	}
	*/

	/* Remove shdf file if user wanted to for non-first file from the list. 
	 *  The first file will be removed if appropriate. 
	 */
	if (i > 0 && remove_shdf_files) remove (ss_infile);
	/* Removed tmp uncompressed file if applied. */
	if (i > 0 && remove_tmp_file) remove(infile);

	if (TKwriteGrid(&ghdf_fd, pgrid) != TK_SUCCESS) {
	  fprintf(stderr, "TKwriteGrid failed for <%s>\n", outfile);
	  TKreportWarning(W_GVFC_S2G_WRITE_OUTFILE_FAILED);
	  TKclose(&ghdf_fd);
	  return (-1);
	}	
  } /* For each infile */

  if (strlen(first_infile)  == 0) {
	if (verbose) fprintf(stderr, "No single VOS for granulizing.\n");
	TKclose(&ghdf_fd);
	return -1;
  }
  if (verbose) fprintf(stderr, "Start writing metadata...\n");

  memset(qc_filename, '\0', MAX_FILENAME_LEN);

  get_qc_hdf_fname(first_infile, qc_dirs_list, prod_ver_qc, qc_filename);

  if (verbose) {
	fprintf(stderr, "Read metadata from qc_filename=<%s>, first_infile=<%s>", qc_filename, first_infile);
	if (metadata_file) 
	  fprintf(stderr, "metadata_file=<%s>\n", metadata_file);
	else fprintf(stderr, "\n");
  }

  nvos = i;
  if (verbose) 
	fprintf(stderr, " Writing metadata to file...\n");

  write_metadata(qc_filename, first_infile, metadata_file, param_file,
				 &begin_date, &end_date, &begin_time, &end_time, nvos, 
				 pcode, outfile, &ghdf_fd);

  /* Remove the first shdf file if user wanted to or compress it.
   */
  if (remove_shdf_files && first_infile != NULL) remove (ss_first_infile);
  if (remove_first_file) remove(first_infile);

  if (verbose) 
	fprintf(stderr, "Closing ghdf file <%s>\n", outfile);
  /* close ghdf file */
  if (TKclose(&ghdf_fd) == TK_FAIL) {
	fprintf(stderr, "Can't close file <%s>\n", outfile);
	TKreportWarning(W_GVFC_S2G_CLOSE_OUTFILE_FAILED);
	return(-1);  
  }

  /* Compress the output  if user wanted to */
  if (compress_ghdf_file) {
	if (verbose)
	  fprintf(stderr, "Compressing...%s.\n", outfile);
	compress_file(outfile, NULL);
  }

  return 1;
} /* granulize_hdf */



int write_metadata (char *qc_filename, char *first_infile, 
					char *metadata_file, char *param_file,
					DATE_STR *begin_date, 
					DATE_STR *end_date, TIME_STR *begin_time, 
					TIME_STR *end_time,	int nvos,  char pcode,
					char *outfile,
					IO_HANDLE *ghdf_fd)
{
  /* Get metadata field values from qc_filename and first_infile and
   * write them plus other metadata fields from matadata_file 
   * to the opened-hdf file.
   * If first_infile, qc_filename, or metadata file is not specified, 
   * give warning and use toolkit defined default values
   *
   * metadata_file format: 
   *    line 1: input files separated by space
   *    line 2: input files' generated date separated by space
   *    line 3: program's runtime options.
   *
   * Return 1 upon successful; -1, otherwise.
   */
  gv_metadata_t metadata;

  if (ghdf_fd == NULL) return -1;

  memset(&metadata, '\0', sizeof(gv_metadata_t));

  if (first_infile != NULL) {
	if (verbose)
	  fprintf(stderr, "Reading prod specific metadata from voshdf... %s\n", first_infile);
  /* Read product specific metadata from the first file */

	if (read_prod_specific_metadata_from_voshdf(first_infile, pcode, 
											  &metadata) < 0) {
	  fprintf(stderr, "Warning: Failed reading product specific metadata from shdf file <%s>\n",  first_infile);
	}
  }


  if (param_file != NULL) {
	if (verbose)
	  fprintf(stderr, "Reading prod specific metadata from file... <%s>\n", param_file);
	if (read_prod_specific_metadata_from_file(param_file, &metadata) < 0) {
	fprintf(stderr, "Warning: Failed reading product specific metadata from param file<%s>\n",  param_file);
	}
  }

  /* Read generic metadata from the qc hdf file */
  if (qc_filename != NULL) {
	if (verbose)
	  fprintf(stderr, "Reading generic metadata from qchdf... %s\n", qc_filename);
	 if (read_generic_metadata_from_qchdf(qc_filename, &metadata) < 0) {
	fprintf(stderr, "Warning: Failed reading generic metadata from qc hdf file <%s>\n",  qc_filename);
	 }
  }

  if (verbose)
	fprintf(stderr, "Done reading metadata from qchdf.\n");


  if (strrchr(outfile, '/') != NULL)
	strcpy(metadata.granule_id, strrchr(outfile, '/') + 1);
  else
	strcpy(metadata.granule_id, outfile);

  metadata.num_vos = nvos;

  /* The begin date/time is when the granule (hour) begins.
   * The end date/time is when the granule (hour) ends.
   */
  
  memcpy(&(metadata.begin_date), begin_date, sizeof(DATE_STR));
  memcpy(&(metadata.begin_time), begin_time, sizeof(TIME_STR));
 
  set_granule_dateNtime(&(metadata.begin_date), &(metadata.begin_time),
						&(metadata.end_date), &(metadata.end_time));

  /* These fields are unknown so use default */
  metadata.num_data_gap = 0;
  metadata.data_gap = 0;
  strcpy(metadata.percent_bad_miss_pixel, "");
  metadata.leap_secs_flag = 0;       

  if (verbose)
	fprintf(stderr, "calling write_hdf_metadata_for_l2granule...\n");
  if (get_metadata_from_metadata_file(metadata_file, &metadata.end_date, NULL, &metadata) < 0) return -1;
  /* Write metadata to granuled hdf file */
  if (write_hdf_metadata_for_l2granule(ghdf_fd, &metadata, verbose) < 0) {
	fprintf(stderr, "Warning: Failed writing metadata to file.\n");
  }

  return 1;
} /* write_metadata */




int open_hdf_file(char *hdf_fname, char mode, char pcode, IO_HANDLE *hdf_fd)
{
  /*
   * Return 1 upon successful; -1, otherwise.
   */
  int status;

  if (hdf_fname == NULL || strlen(hdf_fname) < 1|| hdf_fd == NULL) return -1;
  memset(hdf_fd, '\0', sizeof(IO_HANDLE));

  /* open HDF file */
  switch (pcode) {
	case '3':  /* 2A-53 */
	
	  /* open hdf file */
	  status = TKopen(hdf_fname, TK_L2A_53S, mode, hdf_fd);
	  break;
	
	case '4':  /* 2A-54 */
	  status = TKopen(hdf_fname, TK_L2A_54S, mode, hdf_fd);
	  break;
	case '5':  /* 2A-55 */
	  status = TKopen(hdf_fname, TK_L2A_55S, mode, hdf_fd);
	  break;

  default:
	fprintf(stderr, "product code <%c> is unknown\n", pcode);
	return -1;
  }
  /* Check the Error Status */
  if (status != TK_SUCCESS) {
	return -1;
  }
  return 1;

} /* open_hdf_file */


int read_generic_metadata_from_qchdf(char *qcfile, gv_metadata_t *metadata)
{
  /*
   * Return 1 upon successful; -1, otherwise.
   */
  int status = 1;
  IO_HANDLE hdf_fd;
  char *qcfile_ptr = NULL;
  char tmp_fname[MAX_FILENAME_LEN], *tmp_ptr;
  int remove_tmp_file = 0;

  if (qcfile == NULL || !file_exist(qcfile) || strlen(qcfile) < 1 || metadata == NULL) return -1;

  /* Uncompress file if necessary */
  if ((tmp_ptr = strstr(qcfile, ".gz")) || (tmp_ptr = strstr(qcfile, ".Z"))) {
	if (strrchr(qcfile, '/') != NULL)
	  qcfile_ptr = strrchr(qcfile, '/') +1;
	else
	  qcfile_ptr = qcfile;
	memset(tmp_fname, '\0', MAX_FILENAME_LEN);
	strncpy(tmp_fname, qcfile_ptr, strlen(qcfile_ptr) - strlen(tmp_ptr));

	uncompress_file(qcfile, tmp_fname);
	qcfile = tmp_fname;
	remove_tmp_file = 1;
  }
  memset(&hdf_fd, '\0', sizeof(IO_HANDLE));

  if (TKopen(qcfile, TK_L1C_GV, TK_READ_ONLY, &hdf_fd) != TK_SUCCESS) {
	if (verbose) fprintf(stderr, "Failed to open qc file <%s>\n", qcfile);
	return -1;
  }

  if (read_hdf_metadata_from_qc(&hdf_fd, metadata, verbose) < 0) {
	if (verbose) fprintf(stderr, "read_hdf_metadata_from_qc_fd failed\n");

	status = -1;
  }
  
   /* close file */
  if (TKclose(&hdf_fd) == TK_FAIL) {
	if (verbose) fprintf(stderr, "Can't close <%s>\n", qcfile);
	status = -1;
  }
  
  if (remove_tmp_file) remove(qcfile);
  return status;
}  /* read_generic_metadata_from_qchdf */


int read_prod_specific_metadata_from_voshdf(char *vosfile,
											char pcode,
											gv_metadata_t *metadata)
{
  /*
   * Return 1 upon successful; -1, otherwise.
   */
  IO_HANDLE hdf_fd;
  int status = 1;

  if (metadata == NULL || !file_exist(vosfile) || vosfile == NULL) return -1;
  
  if (open_hdf_file(vosfile, TK_READ_ONLY, pcode, &hdf_fd) < 0) {
	if (verbose) 
	  fprintf(stderr, "Failed to read metadata fields from vos hdf file <%s>.\n",
			vosfile);
	return -1;
  }
  
  if (read_hdf_metadata_from_l2vos(&hdf_fd, metadata, verbose) < 0) {
	if (verbose)
	  fprintf(stderr, "read_hdf_metadata_from_l2vos failed\n");
	status = -1;
  }

  /* close file */
  if (TKclose(&hdf_fd) == TK_FAIL) {
	if (verbose) fprintf(stderr, "Can't close <%s>\n", vosfile);
	status = -1;
  }
  
  return status;
} /* read_prod_specific_metadata_from_voshdf */



int read_prod_specific_metadata_from_file(char *fname, gv_metadata_t *metadata)
{
  /* Read some of metadata fields from file.
   * File should have this format:
   *    line 1: input files separated by space
   *    line 2: input files' generated date separated by space
   *    line 3: program's runtime options.
   *
   * Return 1 upon successful; -1, otherwise.
   */

  FILE *fp;
  long_name_t input_files;
  name_t      input_files_gen_dates;
  very_long_name_t      runtime_opts;
  char *rc;
  int len;

  if (fname == NULL || metadata == NULL) return -1;
  
  memset(runtime_opts, '\0', sizeof(very_long_name_t));
  memset(input_files_gen_dates, '\0', sizeof(name_t));
  memset(input_files, '\0', sizeof(long_name_t));

  if ((fp = fopen(fname, "r")) == NULL) return -1;
  rc = fgets(input_files, sizeof(long_name_t), fp);
  if (rc == NULL) goto FAILURE;
  rc = fgets(input_files_gen_dates, sizeof(name_t), fp);
  if (rc == NULL) goto FAILURE;
  rc = fgets(runtime_opts, sizeof(very_long_name_t), fp);
  if (rc == NULL) goto FAILURE;
  fclose(fp);

  /* Remove \n from strings */
  len = strlen(input_files);
  if (len < 1) return -1;
  if (input_files[len-1] == '\n') 
	input_files[len-1] = '\0';

  len = strlen(input_files_gen_dates);
  if (len < 1) return -1;
  if (input_files_gen_dates[len-1] == '\n') 
	input_files_gen_dates[len-1] = '\0';

  len = strlen(runtime_opts);
  if (len < 1) return -1;
  if (runtime_opts[len-1] == '\n') 
	runtime_opts[len-1] = '\0';

  strcpy(metadata->input_files, input_files);
  strcpy(metadata->gen_date_input_files, input_files_gen_dates);
  strcpy(metadata->runtime_opt, runtime_opts);

  return 1;

FAILURE:
  if (fp) fclose(fp);
  return -1;
} /* read_prod_specific_metadata_from_file */

int read_grid_from_shdf_file(char pcode, char *hdffile, void *grid,   
							 DATE_STR *vos_date, TIME_STR *vos_time)
{
  IO_HANDLE hdf_fd;

  if (grid == NULL || hdffile == NULL) return -1;

  if (open_hdf_file(hdffile, TK_READ_ONLY, pcode, &hdf_fd) < 0) {
	fprintf(stderr, "TKopen failed for file <%s>\n", hdffile);
	TKreportWarning(W_GVFC_S2G_OPEN_INFILE_FAILED);
	return (-1);
  }

  /* read grid from file */
  if (TKreadGrid(&hdf_fd, grid) != TK_SUCCESS) {
	fprintf(stderr, "TKreadGrid failed from file <%s>\n", hdffile);
	TKreportWarning(W_GVFC_S2G_READ_INFILE_FAILED);
	TKclose(&hdf_fd);
	return (-1);
  }	

  READ_METADATA_INT(&hdf_fd, TK_BEGIN_DATE, vos_date);
  READ_METADATA_INT(&hdf_fd, TK_BEGIN_TIME, vos_time);
   
  /* close file */
  if (TKclose(&hdf_fd) == TK_FAIL) {
	fprintf(stderr, "Can't close <%s>\n", hdffile);
	TKreportWarning(W_GVFC_S2G_CLOSE_INFILE_FAILED);
	return(-1);  
  }
  return 1;
} 


void handler(int sig)
{
  fprintf(stderr, "Got signal %d. Abort.\n", sig);
  if (sig == SIGINT || sig == SIGKILL || sig == SIGSTOP) {
	 TKreportWarning(W_GVFC_S2G_ABORT_EXEC);
	exit(-2);
  }
  TKreportWarning(W_GVFC_S2G_STOP_ON_ERROR);
  exit(-1);
}


int get_granule_for_file(char *fname, char *granule_str)
{
  char date[7], granule_id[3];
  int rc = 0;
  char *tmp_str, *filename;

  if (fname == NULL || granule_str == NULL) return -1;

  memset(date, '\0', 7);
  memset(granule_id, '\0', 3);

  filename = fname;
  /* Skip pathname */
  if (strrchr(fname, '/'))
	  filename = strrchr(fname, '/') + 1;

  /* Expect filename =  2A54.921002.11.MELB.1.1159.hdf */
  if (filename+5)
	strncpy(date, filename+5, 6);
  else rc = -1;
  tmp_str = filename+12;
  if (tmp_str && strchr(tmp_str, '.')) 
	strncpy(granule_id, tmp_str, strlen(tmp_str) - strlen(strchr(tmp_str, '.')));
  else rc = -1;
  if (rc == -1) {
	fprintf(stderr, "Format of <%s> is not expected. Expect something like '2A54.921002.11.MELB.1.1159.hdf' \n", filename);
	return -1;
  }
  sprintf(granule_str, "%s.%s", date, granule_id);

  return 1;
} /* get_granule_for_file */


int construct_ghdf_filename(char *core_filename, char *prod_str, char *output_dir, 
							char *outfile)
{
  /* Construct granuled hdf filename that follows TSDIS' filename convention,
   * i.e.,  2A54.921002.11.MELB.1.HDF
   * output_dir can be "" or NULL.
   */
  char *base_filename, *tmp_s = NULL;
  char tmp_fname[MAX_FILENAME_LEN];

  if (core_filename == NULL || outfile == NULL) 
	return -1;

  strcpy(tmp_fname, core_filename);
  base_filename = tmp_fname;
  /* Skip pathname */
  if (strrchr(tmp_fname, '/') != NULL)
	base_filename = strrchr(tmp_fname, '/') + 1;

  if (output_dir != NULL && strlen(output_dir) > 0) {
	strcpy(outfile, output_dir);
	strcat(outfile, "/");
  }
  /* base filename, i.e., *921002.11.MELB.1.1159.hdf* --
   * Replace HHMM.hdf* with .HDF 
   */
  if (strstr(base_filename, ".hdf")) {
	tmp_s = strstr(base_filename, ".hdf");
	*(tmp_s-5) = '\0';
  }

  tmp_s = base_filename;
  if (tmp_s == NULL) {
	strcpy(outfile, "");
	return -1;
  }
  /* Append 4-char prod name if base filename doesnot contain it.
   *  Now, tmp_s, i.e., *921002.11.MELB.1.HDF 
   */
  if (strchr(tmp_s, '.') && 
	  (strlen(base_filename) - strlen(strchr(tmp_s, '.'))) == 6) 
	if (strlen(prod_str) > 0) {
	  strcat(outfile, prod_str);    /* append 4-char prod name*/
	  strcat(outfile, ".");
	}
  /* base filename, i.e., 1C51.921002.11.MELB.1.HDF
   */
  strcat(outfile, base_filename);
  strcat(outfile, ".HDF");
  *(outfile+MAX_FILENAME_LEN-1) = '\0';
  return 1;
} /* construct_ghdf_filename */




int granulize_hdf_for_dir(char product_code, char *input_dir,
						  char *qc_dirs_list, int prod_ver_qc,
                          char * metadata_file, char *param_file,
						  char *output_dir)
{
  char outfile[MAX_FILENAME_LEN], fname[MAX_FILENAME_LEN];
  char *infile_list[MAX_VOS_NUM];
  char curr_granule[MAX_FILENAME_LEN], file_granule[MAX_FILENAME_LEN];
  int rc = 1, rc1;
  int i, fnum = 0;
  char cmd[MAX_STR_LEN], *fname_ptr;
  FILE *fp;

  if (input_dir == NULL) return -1;
  /* Open a pipe of input_dir*.hdf files, sorted.
   */
  memset(cmd, '\0', MAX_STR_LEN);
  sprintf(cmd, "/bin/ls -1 %s/*.hdf*|sort ", input_dir);
  if ((fp = (FILE *)popen(cmd, "r")) == NULL) {
	perror("popen");
	return -1;
  }

  /* Clear buffers */
  for (i = 0; i < MAX_VOS_NUM; i++) infile_list[i] = NULL;
  memset(curr_granule, '\0', MAX_FILENAME_LEN);
  memset(fname, '\0', MAX_FILENAME_LEN);
  while (fgets(fname, MAX_FILENAME_LEN, fp) != NULL) {
	/* Expects files end with .hdf and are sorted in the order of time. */

	/* Remove '\n' from fname */
	fname[strlen(fname)-1] = '\0';

	/* Set curr_granule  */
	if (strlen(curr_granule) == 0 && 
		get_granule_for_file(fname, curr_granule) < 0) {
	  rc = -1;
	  goto DONE;
	}

	memset(file_granule, '\0', MAX_FILENAME_LEN);
	if (get_granule_for_file(fname, file_granule) < 0) {
	  rc = -1;
	  goto DONE;
	}

	/* Compare file's granule and current granule */
	if (strcmp(curr_granule, file_granule) == 0) {

	}
	else {
	  /* This file doesnot belong to the current granule.
	   * Create granule file for the current granule.
	   * Set new current granule. 
	   */
	  /* Set outfile name */
	  memset(outfile, '\0', MAX_FILENAME_LEN);
	  rc1 = construct_ghdf_filename(infile_list[0], "", output_dir, outfile);
	  if (rc1 < 0) {
		if (verbose)
		  fprintf(stderr, "Can't construct granule hdf filename base on %s. Ignore.\n", infile_list[0]);
	  }

	  if (rc1 > 0 && 
		  granulize_hdf(product_code, input_dir, infile_list, qc_dirs_list, prod_ver_qc,
						metadata_file, param_file, outfile) < 0) {
		rc = -1;
		goto DONE;
	  }
		
	  /* Clear buffers. */
	  for (i = 0; i < fnum; i++) {
		if (infile_list[i]) free(infile_list[i]);
		infile_list[i] = NULL;
	  }
	  fnum = 0;
	  /* Set curr granule */
	  strcpy(curr_granule, file_granule);
	}

	/* This file belongs to the current granule 
	 * Add filename to infile list without the pathname.
	 */
	fname_ptr = fname;
	if (strrchr(fname_ptr, '/') != NULL && strrchr(fname_ptr, '/') + 1 != NULL) 
	  infile_list[fnum++] = strdup(strrchr(fname_ptr, '/') +1);
	else
	  infile_list[fnum++] = strdup(fname);
	memset(fname, '\0', MAX_FILENAME_LEN);
  }
  /* 
   * Create granule file for the last granule.
   */

  if (infile_list[0] != NULL) {
	/* Set outfile name */
	memset(outfile, '\0', MAX_FILENAME_LEN);
	rc1 = construct_ghdf_filename(infile_list[0], "", output_dir, outfile);
	if (rc1 > 0 &&
		granulize_hdf(product_code, input_dir, infile_list, qc_dirs_list, prod_ver_qc,
					  metadata_file, param_file, outfile) < 0) {
	  rc = -1;
	  goto DONE;
	}
  }
DONE:
  /* Clear buffers */
  for (i = 0; i < fnum; i++) {
	if (infile_list[i]) free(infile_list[i]);
	infile_list[i] = NULL;
  }
  pclose(fp);
  return rc;
} /* granulize_hdf_for_dir */

int main(int argc, char **argv)
{
  char                    outfile[MAX_FILENAME_LEN], full_outfile[MAX_FILENAME_LEN];
  char                    *qc_dirs_list = NULL, *metadata_file = NULL;
  char                    *param_file = NULL;
  char                    product_code;
  char                    *infile_list[MAX_VOS_NUM];
  int                     i;
  char                    *input_dir = NULL, *output_dir = NULL;
  int                     read_from_dir = 0;
  int                     rc;
  int                     prod_ver_qc;

  signal(SIGINT, handler);
  signal(SIGSTOP, handler);
  signal(SIGFPE, handler);
  signal(SIGKILL, handler);
  signal(SIGILL, handler);
  signal(SIGSEGV, handler);

  verbose = 0;
  remove_shdf_files = 0;
  compress_ghdf_file = 0;
  for (i = 0; i < MAX_VOS_NUM; i++)
	infile_list[i] = NULL;
  input_dir = ".";
  output_dir = ".";
  memset(outfile, '\0', MAX_FILENAME_LEN);
  memset(full_outfile, '\0', MAX_FILENAME_LEN);
  prod_ver_qc = 0;
  process_argv(argc, argv, &product_code, infile_list, outfile, &verbose,
			   &input_dir, &output_dir, &read_from_dir, &qc_dirs_list, 
			   &metadata_file, &param_file, &prod_ver_qc);

  /* Set default if they are not specified by user */
  if (metadata_file == NULL) {
	char *path;
	char *f[] = {NULL, NULL, NULL,
				 "2A53_metadata.txt",
				 "2A54_metadata.txt",
				 "2A55_metadata.txt"};
	int iprod;

	path = getenv("GVS_DATA_PATH");
	iprod = product_code - '0';
	metadata_file = (char *)calloc(strlen(path)+strlen(f[iprod])+2, sizeof(char));
	sprintf(metadata_file, "%s/%s", path, f[iprod]);
  }
  if (qc_dirs_list == NULL) qc_dirs_list = "./";

  if (read_from_dir == 0 && infile_list[0] == NULL) {
	TKreportWarning(W_GVFC_S2G_NO_INFILE);
	exit(-1);
  }

  /* Don't use output_dir if outfile contains pathname */
  if (strchr(outfile, '/') != NULL) 
	sprintf(full_outfile, "%s", outfile);
  else
	sprintf(full_outfile, "%s/%s", output_dir, outfile);

  full_outfile[MAX_FILENAME_LEN-1] = '\0';
  if (verbose) {
	if (read_from_dir == 0) {
	  for (i = 0; i < MAX_VOS_NUM && infile_list[i]; i++) {
		fprintf(stderr, "infile [%d]= <%s>\n", i, infile_list[i]);
	  }
	  fprintf(stderr, "outfile = <%s>\n", full_outfile);

	}
	else {
	  fprintf(stderr, "Read single vos files from dir = <%s>\n", input_dir);
	  fprintf(stderr, "output_dir = <%s>\n", output_dir);
	  fprintf(stderr, "outfile = <%s>\n", outfile);
	}
	fprintf(stderr, "product_code = <%c>\n", product_code);
  }

  if (read_from_dir) 
	rc = granulize_hdf_for_dir(product_code, input_dir, qc_dirs_list, prod_ver_qc,
							   metadata_file, param_file, output_dir);
  else {
	rc = granulize_hdf(product_code, input_dir, infile_list, qc_dirs_list, prod_ver_qc,
					    metadata_file, param_file, full_outfile);
  }

  if (rc < 0) {
	  fprintf(stderr, "Failed to granulize.\n");
	  TKreportWarning(W_GVFC_S2G_GRANULIZE_FAILED);
	  exit(-1);
  }


  if (verbose)
	fprintf(stderr, "Granulized was successful.\n");
  exit (0);
	
} /* main */
